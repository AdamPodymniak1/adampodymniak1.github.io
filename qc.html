<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Quantum Circuit Simulator</title>
<style>
body {
  margin: 0;
  background: #0a0e1a;
  color: #e0e0ff;
  font-family: 'Segoe UI', system-ui, sans-serif;
  overflow: hidden;
}

header {
  padding: 16px;
  text-align: center;
  background: linear-gradient(135deg, #151a3a 0%, #0f1433 100%);
  font-weight: 700;
  font-size: 1.4rem;
  border-bottom: 1px solid #2a2f4a;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.header-controls {
  display: flex;
  gap: 10px;
  align-items: center;
}

.header-controls input {
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid #4a57ff;
  color: white;
  padding: 6px 12px;
  border-radius: 6px;
  width: 60px;
}

.app {
  display: flex;
  height: calc(100vh - 70px);
  overflow: hidden;
}

.sidebar {
  width: 240px;
  background: #121634;
  display: flex;
  flex-direction: column;
  border-right: 1px solid #2a2f4a;
}

.palette-section {
  padding: 16px;
  border-bottom: 1px solid #2a2f4a;
  overflow-y: auto;
  flex-shrink: 0;
}

.palette-section h3 {
  margin-top: 0;
  margin-bottom: 12px;
  font-size: 0.9rem;
  color: #8a8aff;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.gate {
  background: linear-gradient(135deg, #2f3cff 0%, #1a27d8 100%);
  border-radius: 8px;
  padding: 10px;
  margin-bottom: 8px;
  text-align: center;
  cursor: grab;
  font-weight: bold;
  border: 1px solid #4a57ff;
  transition: all 0.2s;
  user-select: none;
  position: relative;
}

.gate:hover {
  background: linear-gradient(135deg, #3f4cff 0%, #2a37e8 100%);
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(47, 60, 255, 0.3);
}

.gate:active {
  transform: translateY(0);
}

.gate.control {
  background: linear-gradient(135deg, #ff3c7c 0%, #d81a5a 100%);
  border-color: #ff5a8c;
}

.gate.multi {
  background: linear-gradient(135deg, #3cffb2 0%, #1ad88a 100%);
  border-color: #5affc2;
}

.gate.measure {
  background: linear-gradient(135deg, #ffb23c 0%, #d88a1a 100%);
  border-color: #ffc25a;
}

.controls {
  padding: 16px;
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.controls button {
  padding: 12px;
  border: none;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  gap: 8px;
  justify-content: center;
}

.controls button.primary {
  background: linear-gradient(135deg, #3cffb2 0%, #1ad88a 100%);
  color: #003322;
}

.controls button.secondary {
  background: linear-gradient(135deg, #2f3cff 0%, #1a27d8 100%);
  color: white;
}

.controls button.danger {
  background: linear-gradient(135deg, #ff3c7c 0%, #d81a5a 100%);
  color: white;
}

.controls button:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

.controls button:active {
  transform: translateY(0);
}

.qubit-controls {
  display: flex;
  gap: 5px;
  margin-bottom: 10px;
}

.qubit-controls button {
  flex: 1;
  padding: 8px;
  font-size: 12px;
}

.circuit-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.circuit-header {
  padding: 10px 20px;
  background: rgba(15, 20, 51, 0.7);
  border-bottom: 1px solid #2a2f4a;
  display: flex;
  gap: 20px;
  align-items: center;
  flex-shrink: 0;
}

.circuit-container {
  flex: 1;
  overflow: auto;
  padding: 20px;
  position: relative;
  background: #0c1022;
}

.grid {
  display: inline-block;
  min-width: 100%;
  position: relative;
  user-select: none;
}

.wire-container {
  display: flex;
  height: 80px;
  align-items: center;
  border-bottom: 1px solid #2a2f4a;
  position: relative;
}

.wire-label {
  width: 60px;
  text-align: center;
  font-weight: bold;
  color: #8a8aff;
  font-size: 0.9rem;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 5px;
}

.wire {
  flex: 1;
  height: 2px;
  background: #4a4a6a;
  position: relative;
}

.column {
  display: inline-block;
  width: 100px;
  position: relative;
  min-height: 80px;
}

.gate-slot {
  width: 60px;
  height: 60px;
  border: 2px dashed #555;
  border-radius: 10px;
  background: rgba(15, 20, 51, 0.7);
  position: absolute;
  left: 20px;
  top: 50%;
  transform: translateY(-50%);
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  font-size: 1.2rem;
  color: white;
  transition: all 0.2s;
  cursor: pointer;
  z-index: 10;
}

.gate-slot:hover {
  border-color: #8a8aff;
  background: rgba(15, 20, 51, 0.9);
}

.gate-slot.filled {
  border-style: solid;
  background: linear-gradient(135deg, #2f3cff 0%, #1a27d8 100%);
  box-shadow: 0 4px 12px rgba(47, 60, 255, 0.3);
}

.gate-slot.control-gate {
  background: linear-gradient(135deg, #ff3c7c 0%, #d81a5a 100%);
  border-color: #ff5a8c;
}

.gate-slot.multi-gate {
  background: linear-gradient(135deg, #3cffb2 0%, #1ad88a 100%);
  border-color: #5affc2;
}

.gate-slot.measure-gate {
  background: linear-gradient(135deg, #ffb23c 0%, #d88a1a 100%);
  border-color: #ffc25a;
}

.gate-slot.control-dot {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background: white;
  border: 3px solid #ff3c7c;
}

.gate-slot.swap-gate {
  background: linear-gradient(135deg, #b23cff 0%, #8a1ad8 100%);
  border-color: #c25aff;
}

.gate-slot .remove-btn {
  position: absolute;
  top: -8px;
  right: -8px;
  width: 20px;
  height: 20px;
  background: #ff3c3c;
  border: none;
  border-radius: 50%;
  color: white;
  font-size: 12px;
  cursor: pointer;
  opacity: 0;
  transition: opacity 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 100;
}

.gate-slot:hover .remove-btn {
  opacity: 1;
}

.control-line {
  position: absolute;
  width: 2px;
  background: white;
  left: 50%;
  transform: translateX(-50%);
  z-index: 1;
}

.control-dot {
  width: 14px;
  height: 14px;
  background: white;
  border-radius: 50%;
  position: absolute;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 2;
  border: 2px solid #0a0e1a;
}

.measure-indicator {
  width: 0;
  height: 0;
  border-left: 10px solid transparent;
  border-right: 10px solid transparent;
  border-bottom: 16px solid #ffb23c;
  position: relative;
}

.measure-indicator::after {
  content: '';
  position: absolute;
  width: 8px;
  height: 12px;
  background: #003322;
  top: 8px;
  left: -4px;
}

.swap-cross {
  position: relative;
  width: 40px;
  height: 40px;
}

.swap-cross::before,
.swap-cross::after {
  content: '';
  position: absolute;
  background: white;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.swap-cross::before {
  width: 100%;
  height: 4px;
}

.swap-cross::after {
  width: 4px;
  height: 100%;
}

.results {
  padding: 20px;
  background: #121634;
  border-top: 1px solid #2a2f4a;
  max-height: 40vh;
  overflow: auto;
  flex-shrink: 0;
}

.result-section {
  margin-bottom: 20px;
}

.result-section h3 {
  margin-top: 0;
  color: #8a8aff;
  font-size: 1rem;
}

.bloch-container {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
  margin-top: 15px;
}

.bloch-sphere {
  position: relative;
  background: #0f1433;
  border-radius: 10px;
  border: 1px solid #2a2f4a;
  padding: 15px;
  min-width: 240px;
}

.bloch-canvas {
  background: #0f1433;
  border-radius: 8px;
  display: block;
  margin: 0 auto;
}

.bloch-label {
  text-align: center;
  margin-top: 8px;
  font-weight: bold;
  color: #8a8aff;
}

.bloch-info {
  text-align: center;
  margin-top: 8px;
  font-size: 0.9rem;
  color: #aaa;
}

.probability-bars {
  display: flex;
  height: 100px;
  align-items: flex-end;
  gap: 4px;
  margin-top: 10px;
  padding: 10px;
  background: rgba(15, 20, 51, 0.7);
  border-radius: 8px;
}

.prob-bar {
  flex: 1;
  background: linear-gradient(to top, #2f3cff, #3cffb2);
  border-radius: 4px 4px 0 0;
  position: relative;
  min-height: 4px;
  transition: height 0.3s ease;
}

.prob-label {
  position: absolute;
  bottom: -20px;
  left: 0;
  right: 0;
  text-align: center;
  font-size: 0.8rem;
  color: #aaa;
}

.state-vector {
  background: rgba(15, 20, 51, 0.7);
  padding: 15px;
  border-radius: 8px;
  font-family: 'Courier New', monospace;
  font-size: 0.9rem;
  line-height: 1.6;
  max-height: 200px;
  overflow: auto;
  white-space: pre-wrap;
}

.state-info {
  display: flex;
  flex-wrap: wrap;
  gap: 15px;
  margin-bottom: 20px;
}

.info-box {
  background: rgba(15, 20, 51, 0.7);
  padding: 15px;
  border-radius: 8px;
  flex: 1;
  min-width: 200px;
}

.info-box h4 {
  margin-top: 0;
  color: #8a8aff;
}

#output {
  white-space: pre-wrap;
  background: rgba(15, 20, 51, 0.7);
  padding: 15px;
  border-radius: 8px;
  font-family: 'Courier New', monospace;
  font-size: 0.9rem;
  max-height: 150px;
  overflow: auto;
}

.context-menu {
  position: fixed;
  background: #121634;
  border: 1px solid #2a2f4a;
  border-radius: 8px;
  padding: 8px 0;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
  z-index: 1000;
  min-width: 150px;
  display: none;
}

.context-menu-item {
  padding: 8px 16px;
  cursor: pointer;
  color: #e0e0ff;
  font-size: 14px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.context-menu-item:hover {
  background: #2a2f4a;
}

.context-menu-divider {
  height: 1px;
  background: #2a2f4a;
  margin: 4px 0;
}

.gate-config {
  background: rgba(15, 20, 51, 0.9);
  border: 1px solid #4a57ff;
  border-radius: 8px;
  padding: 15px;
  position: absolute;
  z-index: 1001;
  min-width: 200px;
  display: none;
}

.gate-config h4 {
  margin-top: 0;
  color: #8a8aff;
}

.gate-config input {
  width: 100%;
  padding: 8px;
  margin: 5px 0;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid #4a57ff;
  color: white;
  border-radius: 4px;
}

.gate-config button {
  width: 100%;
  padding: 8px;
  margin-top: 10px;
  background: #3cffb2;
  color: #003322;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-weight: bold;
}

.auto-run {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 10px;
  padding: 10px;
  background: rgba(15, 20, 51, 0.7);
  border-radius: 8px;
}

.auto-run label {
  font-size: 0.9rem;
  color: #8a8aff;
}

.auto-run input[type="checkbox"] {
  transform: scale(1.2);
}
</style>
</head>
<body>
<header>
  <span>‚öõÔ∏è Quantum Circuit Simulator</span>
  <div class="header-controls">
    <span>Shots:</span>
    <input type="number" id="shotsInput" value="1024" min="1" max="10000">
    <span>Qubits:</span>
    <input type="number" id="qubitsInput" value="2" min="1" max="10">
    <button onclick="updateQubitCount()">Update</button>
  </div>
</header>

<div class="app">
  <div class="sidebar">
    <div class="palette-section">
      <h3>Basic Gates</h3>
      <div class="gate" draggable="true" data-gate="H">H</div>
      <div class="gate" draggable="true" data-gate="X">X</div>
      <div class="gate" draggable="true" data-gate="Y">Y</div>
      <div class="gate" draggable="true" data-gate="Z">Z</div>
      <div class="gate" draggable="true" data-gate="S">S</div>
      <div class="gate" draggable="true" data-gate="T">T</div>
    </div>
    
    <div class="palette-section">
      <h3>Control Gates</h3>
      <div class="gate control" draggable="true" data-gate="CNOT">‚óè‚îÄX</div>
      <div class="gate control" draggable="true" data-gate="CY">‚óè‚îÄY</div>
      <div class="gate control" draggable="true" data-gate="CZ">‚óè‚îÄZ</div>
      <div class="gate control" draggable="true" data-gate="CCX">‚óè‚óè‚îÄX</div>
    </div>
    
    <div class="palette-section">
      <h3>Other Gates</h3>
      <div class="gate multi" draggable="true" data-gate="SWAP">SWAP</div>
      <div class="gate multi" draggable="true" data-gate="RX">RX(Œ∏)</div>
      <div class="gate multi" draggable="true" data-gate="RY">RY(Œ∏)</div>
      <div class="gate multi" draggable="true" data-gate="RZ">RZ(Œ∏)</div>
      <div class="gate measure" draggable="true" data-gate="MEASURE">Measure</div>
    </div>
    
    <div class="controls">
      <div class="qubit-controls">
        <button onclick="addQubit()" title="Add Qubit">+ Qubit</button>
        <button onclick="removeQubit()" title="Remove Qubit">- Qubit</button>
      </div>
      <button class="primary" onclick="runCircuit()">‚ñ∂ Run Simulation</button>
      <button class="secondary" onclick="addColumn()">‚ûï Add Column</button>
      <button class="danger" onclick="resetCircuit()">‚ü≥ Reset All</button>
      <button onclick="clearGates()">üóëÔ∏è Clear Gates</button>
      <button onclick="exportCircuit()">üíæ Export</button>
      <button onclick="importCircuit()">üìÇ Import</button>
      
      <div class="auto-run">
        <input type="checkbox" id="autoRun" checked>
        <label for="autoRun">Auto-run on changes</label>
      </div>
    </div>
  </div>

  <div class="circuit-area">
    <div class="circuit-header">
      <div style="color: #8a8aff; font-size: 0.9rem;">
        Drag gates from left panel. Circuit runs automatically on changes.
      </div>
    </div>
    
    <div class="circuit-container">
      <div id="circuit" class="grid"></div>
    </div>
    
    <div class="results">
      <div class="state-info">
        <div class="info-box">
          <h4>State Vector</h4>
          <div id="stateVector" class="state-vector"></div>
        </div>
        <div class="info-box">
          <h4>Measurement Results</h4>
          <div id="probabilityBars" class="probability-bars"></div>
          <pre id="output"></pre>
        </div>
      </div>
      
      <div class="result-section">
        <h3>Bloch Spheres</h3>
        <div id="blochSpheres" class="bloch-container"></div>
      </div>
    </div>
  </div>
</div>

<div id="contextMenu" class="context-menu">
  <div class="context-menu-item" onclick="editGate()">‚úèÔ∏è Edit Gate</div>
  <div class="context-menu-item" onclick="removeSelectedGate()">üóëÔ∏è Remove Gate</div>
</div>

<div id="gateConfig" class="gate-config">
  <h4>Configure Gate</h4>
  <div id="configContent"></div>
  <button onclick="saveGateConfig()">Save</button>
</div>

<script>
const C = (re, im=0) => ({re, im});
const add = (a,b) => C(a.re+b.re, a.im+b.im);
const mul = (a,b) => C(a.re*b.re - a.im*b.im, a.re*b.im + a.im*b.re);
const smul = (s, a) => C(s*a.re, s*a.im);
const abs2 = a => a.re*a.re + a.im*a.im;
const norm = a => Math.sqrt(abs2(a));
const conj = a => C(a.re, -a.im);
const phase = a => Math.atan2(a.im, a.re);

const GATES = {
  H: [[C(1/Math.SQRT2), C(1/Math.SQRT2)], [C(1/Math.SQRT2), C(-1/Math.SQRT2)]],
  X: [[C(0), C(1)], [C(1), C(0)]],
  Y: [[C(0), C(0,-1)], [C(0,1), C(0)]],
  Z: [[C(1), C(0)], [C(0), C(-1)]],
  S: [[C(1), C(0)], [C(0), C(0,1)]],
  T: [[C(1), C(0)], [C(0), C(Math.cos(Math.PI/4), Math.sin(Math.PI/4))]],
  RX: (Œ∏) => [[C(Math.cos(Œ∏/2)), C(0,-Math.sin(Œ∏/2))], [C(0,-Math.sin(Œ∏/2)), C(Math.cos(Œ∏/2))]],
  RY: (Œ∏) => [[C(Math.cos(Œ∏/2)), C(-Math.sin(Œ∏/2))], [C(Math.sin(Œ∏/2)), C(Math.cos(Œ∏/2))]],
  RZ: (Œ∏) => [[C(Math.cos(-Œ∏/2), Math.sin(-Œ∏/2)), C(0)], [C(0), C(Math.cos(Œ∏/2), Math.sin(Œ∏/2))]]
};

let nQubits = 2;
let columns = 6;
let gridData = [];
let draggedGate = null;
let selectedGate = null;
let contextMenu = {col: -1, row: -1};
let circuit = null;
let autoRunEnabled = true;

function initGrid() {
  gridData = [];
  for(let c=0; c<columns; c++) {
    gridData[c] = Array(nQubits).fill(null);
  }
  renderGrid();
  createBlochSpheres();
  if(autoRunEnabled) runCircuit();
}

function updateQubitCount() {
  const input = document.getElementById("qubitsInput");
  const newCount = parseInt(input.value);
  if(newCount >= 1 && newCount <= 10) {
    const oldCount = nQubits;
    nQubits = newCount;
    
    for(let c=0; c<columns; c++) {
      if(nQubits > oldCount) {
        for(let i=oldCount; i<nQubits; i++) {
          gridData[c].push(null);
        }
      } else {
        gridData[c] = gridData[c].slice(0, nQubits);
      }
    }
    renderGrid();
    createBlochSpheres();
    if(autoRunEnabled) runCircuit();
  }
}

function addQubit() {
  if(nQubits < 10) {
    nQubits++;
    document.getElementById("qubitsInput").value = nQubits;
    for(let c=0; c<columns; c++) {
      gridData[c].push(null);
    }
    renderGrid();
    createBlochSpheres();
    if(autoRunEnabled) runCircuit();
  }
}

function removeQubit() {
  if(nQubits > 1) {
    nQubits--;
    document.getElementById("qubitsInput").value = nQubits;
    for(let c=0; c<columns; c++) {
      gridData[c].pop();
    }
    renderGrid();
    createBlochSpheres();
    if(autoRunEnabled) runCircuit();
  }
}

function addColumn() {
  gridData.push(Array(nQubits).fill(null));
  columns++;
  renderGrid();
  if(autoRunEnabled) runCircuit();
}

function resetCircuit() {
  nQubits = 2;
  columns = 6;
  document.getElementById("qubitsInput").value = nQubits;
  initGrid();
  document.getElementById("output").textContent = "";
  document.getElementById("stateVector").textContent = "";
  document.getElementById("probabilityBars").innerHTML = "";
  selectedGate = null;
}

function clearGates() {
  for(let c=0; c<columns; c++) {
    for(let q=0; q<nQubits; q++) {
      gridData[c][q] = null;
    }
  }
  renderGrid();
  if(autoRunEnabled) runCircuit();
}

function createBlochSpheres() {
  const container = document.getElementById("blochSpheres");
  container.innerHTML = "";
  
  for(let q=0; q<nQubits; q++) {
    const sphere = document.createElement("div");
    sphere.className = "bloch-sphere";
    
    const canvas = document.createElement("canvas");
    canvas.className = "bloch-canvas";
    canvas.width = 200;
    canvas.height = 200;
    canvas.id = `bloch${q}`;
    
    const label = document.createElement("div");
    label.className = "bloch-label";
    label.textContent = `Qubit ${q}`;
    
    const info = document.createElement("div");
    info.className = "bloch-info";
    info.id = `blochInfo${q}`;
    
    sphere.appendChild(canvas);
    sphere.appendChild(label);
    sphere.appendChild(info);
    container.appendChild(sphere);
  }
}

function renderGrid() {
  const circuitEl = document.getElementById("circuit");
  circuitEl.innerHTML = "";
  
  for(let q=0; q<nQubits; q++) {
    const wireContainer = document.createElement("div");
    wireContainer.className = "wire-container";
    wireContainer.dataset.row = q;
    
    const wireLabel = document.createElement("div");
    wireLabel.className = "wire-label";
    wireLabel.innerHTML = `|q${q}‚ü©`;
    wireContainer.appendChild(wireLabel);
    
    for(let c=0; c<columns; c++) {
      const column = document.createElement("div");
      column.className = "column";
      column.dataset.col = c;
      column.dataset.row = q;
      
      const wire = document.createElement("div");
      wire.className = "wire";
      column.appendChild(wire);
      
      const slot = document.createElement("div");
      slot.className = "gate-slot";
      slot.dataset.col = c;
      slot.dataset.row = q;
      
      const gateData = gridData[c][q];
      if(gateData) {
        if(gateData.type === 'control-dot') {
          slot.classList.add("control-dot");
          slot.innerHTML = '<div class="control-dot"></div>';
        } else {
          slot.textContent = gateData.gate;
          slot.classList.add("filled");
          
          if(gateData.type === 'control') {
            slot.classList.add("control-gate");
          } else if(gateData.type === 'multi') {
            slot.classList.add("multi-gate");
            if(gateData.gate === 'SWAP') {
              slot.innerHTML = '<div class="swap-cross"></div>';
            }
          } else if(gateData.gate === 'MEASURE') {
            slot.classList.add("measure-gate");
            slot.innerHTML = '<div class="measure-indicator"></div>';
          }
          
          const removeBtn = document.createElement("button");
          removeBtn.className = "remove-btn";
          removeBtn.innerHTML = "√ó";
          removeBtn.onclick = (e) => {
            e.stopPropagation();
            removeGate(c, q);
          };
          slot.appendChild(removeBtn);
        }
      }
      
      slot.oncontextmenu = (e) => {
        e.preventDefault();
        if(gateData) {
          selectedGate = {col: c, row: q, data: gateData};
          showContextMenu(e.clientX, e.clientY, c, q);
        }
      };
      
      slot.onclick = (e) => {
        if(e.target !== slot && !e.target.classList.contains('remove-btn')) {
          if(gateData && ['RX', 'RY', 'RZ'].includes(gateData.gate)) {
            openAngleConfig(c, q, gateData);
          }
        }
      };
      
      slot.ondragover = (e) => {
        e.preventDefault();
        if(!gateData) {
          slot.style.borderColor = "#3cffb2";
          slot.style.background = "rgba(60, 255, 178, 0.1)";
        }
      };
      
      slot.ondragleave = () => {
        slot.style.borderColor = "";
        slot.style.background = "";
      };
      
      slot.ondrop = (e) => {
        e.preventDefault();
        slot.style.borderColor = "";
        slot.style.background = "";
        
        if(!draggedGate || gateData) return;
        
        const col = parseInt(slot.dataset.col);
        const row = parseInt(slot.dataset.row);
        
        if(['CNOT', 'CY', 'CZ'].includes(draggedGate)) {
          for(let i=0; i<nQubits; i++) {
            if(i !== row && !gridData[col][i]) {
              gridData[col][row] = {
                gate: draggedGate,
                type: 'control',
                control: i,
                target: row
              };
              gridData[col][i] = {gate: '‚óè', type: 'control-dot'};
              break;
            }
          }
          if(!gridData[col][row]) {
            alert("Need an empty qubit line for control");
            return;
          }
          
        } else if(draggedGate === 'CCX') {
          const controls = [];
          for(let i=0; i<nQubits; i++) {
            if(i !== row && !gridData[col][i] && controls.length < 2) {
              controls.push(i);
              gridData[col][i] = {gate: '‚óè', type: 'control-dot'};
            }
          }
          if(controls.length === 2) {
            gridData[col][row] = {
              gate: 'CCX',
              type: 'control',
              controls: controls,
              target: row
            };
          } else {
            for(const ctrl of controls) {
              gridData[col][ctrl] = null;
            }
            alert("Need 2 empty qubits for controls");
            return;
          }
        } else if(draggedGate === 'SWAP') {
          let swapRow = -1;
          for(let i=0; i<nQubits; i++) {
            if(i !== row && !gridData[col][i]) {
              swapRow = i;
              break;
            }
          }
          if(swapRow !== -1) {
            gridData[col][row] = {gate: 'SWAP', type: 'multi', swapWith: swapRow};
            gridData[col][swapRow] = {gate: 'SWAP', type: 'multi', swapWith: row};
          } else {
            alert("Need an empty qubit line for SWAP");
            return;
          }
        } else if(['RX', 'RY', 'RZ'].includes(draggedGate)) {
          gridData[col][row] = {gate: draggedGate, type: 'multi', angle: Math.PI/2};
        } else {
          gridData[col][row] = {gate: draggedGate, type: 'basic'};
        }
        
        renderGrid();
        drawControlLines();
        if(autoRunEnabled) runCircuit();
      };
      
      column.appendChild(slot);
      wireContainer.appendChild(column);
    }
    
    circuitEl.appendChild(wireContainer);
  }
  
  drawControlLines();
}

function drawControlLines() {
  document.querySelectorAll(".control-line").forEach(el => el.remove());
  
  for(let c=0; c<columns; c++) {
    for(let q=0; q<nQubits; q++) {
      const gate = gridData[c][q];
      if(gate && gate.type === 'control' && !gate.gate.startsWith('‚óè')) {
        const columnEl = document.querySelector(`.column[data-col="${c}"][data-row="${q}"]`);
        if(columnEl) {
          const controls = gate.controls || [gate.control];
          
          for(const controlRow of controls) {
            if(controlRow !== q) {
              const controlColumn = document.querySelector(`.column[data-col="${c}"][data-row="${controlRow}"]`);
              if(controlColumn) {
                const minRow = Math.min(controlRow, q);
                const maxRow = Math.max(controlRow, q);
                const height = (maxRow - minRow) * 80;
                
                const line = document.createElement("div");
                line.className = "control-line";
                line.style.height = `${height}px`;
                line.style.top = controlRow < q ? "50%" : `${50 - (height/80)*100}%`;
                line.style.zIndex = "5";
                controlColumn.appendChild(line);
              }
            }
          }
        }
      }
    }
  }
}

function removeGate(col, row) {
  const gate = gridData[col][row];
  if(!gate) return;
  
  if(gate.type === 'control') {
    if(gate.controls) {
      for(const ctrl of gate.controls) {
        if(gridData[col][ctrl] && gridData[col][ctrl].gate === '‚óè') {
          gridData[col][ctrl] = null;
        }
      }
    } else if(gate.control !== undefined && gridData[col][gate.control] && gridData[col][gate.control].gate === '‚óè') {
      gridData[col][gate.control] = null;
    }
  } else if(gate.type === 'multi' && gate.gate === 'SWAP' && gate.swapWith !== undefined) {
    if(gridData[col][gate.swapWith] && gridData[col][gate.swapWith].gate === 'SWAP') {
      gridData[col][gate.swapWith] = null;
    }
  }
  
  gridData[col][row] = null;
  renderGrid();
  if(autoRunEnabled) runCircuit();
}

function openAngleConfig(col, row, gateData) {
  selectedGate = {col, row, data: gateData};
  const config = document.getElementById("gateConfig");
  const content = document.getElementById("configContent");
  
  let html = `<label>Angle Œ∏ (radians):</label>
              <input type="number" id="angleInput" value="${gateData.angle || Math.PI/2}" step="0.1" min="0" max="${2*Math.PI}">
              <br><br>
              <label>œÄ multiples:</label>
              <select id="piMultiples" onchange="document.getElementById('angleInput').value=this.value*Math.PI">
                <option value="0.125">œÄ/8</option>
                <option value="0.25">œÄ/4</option>
                <option value="0.5" selected>œÄ/2</option>
                <option value="1">œÄ</option>
                <option value="2">2œÄ</option>
              </select>`;
  
  content.innerHTML = html;
  config.style.display = 'block';
  config.style.left = (col * 100 + 100) + 'px';
  config.style.top = (row * 80 + 100) + 'px';
}

function saveGateConfig() {
  if(!selectedGate) return;
  
  const config = document.getElementById("gateConfig");
  const {col, row, data} = selectedGate;
  
  if(['RX', 'RY', 'RZ'].includes(data.gate)) {
    const angle = parseFloat(document.getElementById("angleInput").value);
    if(!isNaN(angle)) {
      gridData[col][row].angle = angle;
    }
  }
  
  config.style.display = 'none';
  renderGrid();
  if(autoRunEnabled) runCircuit();
}

function showContextMenu(x, y, col, row) {
  const menu = document.getElementById("contextMenu");
  menu.style.left = x + 'px';
  menu.style.top = y + 'px';
  menu.style.display = 'block';
  contextMenu = {col, row};
}

function editGate() {
  const {col, row} = contextMenu;
  const gateData = gridData[col][row];
  if(!gateData) return;
  
  hideContextMenu();
  
  if(['RX', 'RY', 'RZ'].includes(gateData.gate)) {
    openAngleConfig(col, row, gateData);
  }
}

function removeSelectedGate() {
  const {col, row} = contextMenu;
  removeGate(col, row);
  hideContextMenu();
}

function hideContextMenu() {
  document.getElementById("contextMenu").style.display = 'none';
}

document.addEventListener("click", hideContextMenu);
document.addEventListener("contextmenu", hideContextMenu);

document.querySelectorAll(".gate").forEach(g => {
  g.ondragstart = e => {
    draggedGate = g.dataset.gate;
    e.dataTransfer.setData("text/plain", g.dataset.gate);
    g.style.opacity = "0.5";
  };
  g.ondragend = e => g.style.opacity = "1";
});

function drawBlochSphere(q, alpha, beta) {
  const canvas = document.getElementById(`bloch${q}`);
  const info = document.getElementById(`blochInfo${q}`);
  if(!canvas || !info) return;
  
  const ctx = canvas.getContext("2d");
  const width = canvas.width;
  const height = canvas.height;
  const radius = Math.min(width, height) * 0.35;
  const centerX = width / 2;
  const centerY = height / 2;
  
  ctx.clearRect(0, 0, width, height);
  
  const prob0 = abs2(alpha);
  const prob1 = abs2(beta);
  
  if (norm(alpha) === 0 && norm(beta) === 0) return;
  
  const theta = 2 * Math.acos(Math.min(1, Math.max(-1, Math.sqrt(prob0))));
  const phi = phase(beta) - phase(alpha);
  
  const x = Math.sin(theta) * Math.cos(phi);
  const y = Math.sin(theta) * Math.sin(phi);
  const z = Math.cos(theta);
  
  const sphereX = centerX + radius * x;
  const sphereY = centerY - radius * y;
  
  ctx.strokeStyle = "#4a4a6a";
  ctx.lineWidth = 1;
  
  ctx.beginPath();
  ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
  ctx.stroke();
  
  ctx.beginPath();
  ctx.ellipse(centerX, centerY, radius, radius * 0.5, 0, 0, Math.PI * 2);
  ctx.stroke();
  
  ctx.beginPath();
  ctx.ellipse(centerX, centerY, radius * 0.5, radius, 0, 0, Math.PI * 2);
  ctx.stroke();
  
  ctx.beginPath();
  ctx.arc(centerX, centerY, radius, Math.PI, 0);
  ctx.stroke();
  
  ctx.strokeStyle = "#3cffb2";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(centerX, centerY);
  ctx.lineTo(sphereX, sphereY);
  ctx.stroke();
  
  ctx.fillStyle = "#3cffb2";
  ctx.beginPath();
  ctx.arc(sphereX, sphereY, 6, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = "#3cffb2";
  ctx.font = "12px Arial";
  ctx.fillText("|0‚ü©", centerX - radius - 10, centerY - 5);
  ctx.fillText("|1‚ü©", centerX + radius + 5, centerY - 5);
  ctx.fillText("|+‚ü©", centerX - 5, centerY - radius - 10);
  ctx.fillText("|-‚ü©", centerX - 5, centerY + radius + 15);
  
  info.innerHTML = `
    Œ∏ = ${theta.toFixed(3)} rad<br>
    œÜ = ${phi.toFixed(3)} rad<br>
    |0‚ü©: ${(prob0*100).toFixed(1)}%<br>
    |1‚ü©: ${(prob1*100).toFixed(1)}%
  `;
}

function runCircuit() {
  const shotsInput = document.getElementById("shotsInput");
  const shots = parseInt(shotsInput.value) || 1024;
  autoRunEnabled = document.getElementById("autoRun").checked;
  
  circuit = new QuantumCircuit(nQubits);
  
  for(let c=0; c<columns; c++) {
    for(let q=0; q<nQubits; q++) {
      const gateData = gridData[c][q];
      if(!gateData) continue;
      
      if(gateData.type === 'control-dot') continue;
      
      if(gateData.gate === 'CNOT') {
        circuit.applyControlledGate(GATES.X, [gateData.control], gateData.target);
      } else if(gateData.gate === 'CY') {
        circuit.applyControlledGate(GATES.Y, [gateData.control], gateData.target);
      } else if(gateData.gate === 'CZ') {
        circuit.applyControlledGate(GATES.Z, [gateData.control], gateData.target);
      } else if(gateData.gate === 'CCX') {
        circuit.applyControlledGate(GATES.X, gateData.controls, gateData.target);
      } else if(gateData.gate === 'SWAP') {
        circuit.applySWAP(q, gateData.swapWith);
      } else if(gateData.gate === 'RX') {
        circuit.applyGate(GATES.RX(gateData.angle || Math.PI/2), q);
      } else if(gateData.gate === 'RY') {
        circuit.applyGate(GATES.RY(gateData.angle || Math.PI/2), q);
      } else if(gateData.gate === 'RZ') {
        circuit.applyGate(GATES.RZ(gateData.angle || Math.PI/2), q);
      } else if(gateData.gate === 'MEASURE') {
        const probs = circuit.state.map(abs2);
        let r = Math.random(), a = 0;
        for(let i=0; i<probs.length; i++) {
          a += probs[i];
          if(r < a) {
            const collapsed = Array(circuit.dim).fill(C(0));
            collapsed[i] = C(1);
            circuit.state = collapsed;
            break;
          }
        }
      } else if(GATES[gateData.gate]) {
        circuit.applyGate(GATES[gateData.gate], q);
      }
    }
  }
  
  const measurements = circuit.measure(shots);
  const stateVector = circuit.getStateVector();
  
  let output = `Total shots: ${shots}\n\n`;
  let totalShots = 0;
  Object.entries(measurements)
    .sort((a,b) => b[1] - a[1])
    .forEach(([state, count]) => {
      output += `${state}: ${count} (${(count/shots*100).toFixed(1)}%)\n`;
      totalShots += count;
    });
  
  document.getElementById("output").textContent = output;
  
  let stateText = "";
  stateVector.forEach(s => {
    if(s.probability > 0.0001) {
      const amplitude = s.amplitude;
      const prob = s.probability;
      const phaseVal = s.phase;
      stateText += `|${s.state}‚ü©: ${amplitude.re.toFixed(3)}${amplitude.im >= 0 ? '+' : ''}${amplitude.im.toFixed(3)}i\n`;
      stateText += `  Prob: ${(prob*100).toFixed(2)}%, Phase: ${phaseVal.toFixed(3)} rad\n\n`;
    }
  });
  document.getElementById("stateVector").textContent = stateText;
  
  const bars = document.getElementById("probabilityBars");
  bars.innerHTML = "";
  
  const sortedStates = stateVector
    .filter(s => s.probability > 0.0001)
    .sort((a,b) => parseInt(a.state,2) - parseInt(b.state,2));
  
  sortedStates.forEach(s => {
    const bar = document.createElement("div");
    bar.className = "prob-bar";
    bar.style.height = `${s.probability * 100}%`;
    bar.title = `|${s.state}‚ü©: ${(s.probability*100).toFixed(1)}%`;
    
    const label = document.createElement("div");
    label.className = "prob-label";
    label.textContent = `|${s.state}‚ü©`;
    
    bar.appendChild(label);
    bars.appendChild(bar);
  });
  
  for(let q=0; q<nQubits; q++) {
    const alpha = circuit.getQubitState(q, 0);
    const beta = circuit.getQubitState(q, 1);
    drawBlochSphere(q, alpha, beta);
  }
}

class QuantumCircuit {
  constructor(n) {
    this.n = n;
    this.dim = 1 << n;
    this.state = Array(this.dim).fill(C(0));
    this.state[0] = C(1);
  }

  applyGate(gate, target, params=null) {
    let gateMatrix;
    if(typeof gate === 'function') {
      gateMatrix = gate(params);
    } else {
      gateMatrix = gate;
    }
    
    const ns = Array(this.dim).fill(C(0));
    for(let i=0; i<this.dim; i++) {
      const bit = (i >> target) & 1;
      for(let b=0; b<2; b++) {
        const j = (i & ~(1 << target)) | (b << target);
        ns[i] = add(ns[i], mul(gateMatrix[bit][b], this.state[j]));
      }
    }
    this.state = ns;
  }

  applyControlledGate(gate, controls, target, params=null) {
    const ns = Array(this.dim).fill(C(0));
    for(let i=0; i<this.dim; i++) {
      let allControls = true;
      for(const c of controls) {
        if(((i >> c) & 1) === 0) {
          allControls = false;
          break;
        }
      }
      
      if(allControls) {
        const bit = (i >> target) & 1;
        const base = i & ~(1 << target);
        for(let b=0; b<2; b++) {
          const j = base | (b << target);
          let gateMatrix;
          if(typeof gate === 'function') {
            gateMatrix = gate(params);
          } else {
            gateMatrix = gate;
          }
          for(let b2=0; b2<2; b2++) {
            const k = base | (b2 << target);
            ns[j] = add(ns[j], mul(gateMatrix[bit][b2], this.state[k]));
          }
        }
      } else {
        ns[i] = this.state[i];
      }
    }
    this.state = ns;
  }

  applySWAP(q1, q2) {
    const ns = [...this.state];
    for(let i=0; i<this.dim; i++) {
      const bit1 = (i >> q1) & 1;
      const bit2 = (i >> q2) & 1;
      if(bit1 !== bit2) {
        const j = i ^ (1 << q1) ^ (1 << q2);
        ns[j] = this.state[i];
      }
    }
    this.state = ns;
  }

  getQubitState(qubit, value) {
    let sum0 = C(0);
    let sum1 = C(0);
    
    for(let i=0; i<this.dim; i++) {
      const bit = (i >> qubit) & 1;
      if(bit === 0) {
        sum0 = add(sum0, this.state[i]);
      } else {
        sum1 = add(sum1, this.state[i]);
      }
    }
    
    const norm0 = norm(sum0);
    const norm1 = norm(sum1);
    const totalNorm = Math.sqrt(norm0*norm0 + norm1*norm1);
    
    if(totalNorm > 0) {
      sum0 = smul(1/totalNorm, sum0);
      sum1 = smul(1/totalNorm, sum1);
    }
    
    return value === 0 ? sum0 : sum1;
  }

  measure(shots=1024) {
    const probs = this.state.map(abs2);
    const out = {};
    for(let s=0; s<shots; s++) {
      let r = Math.random(), a = 0;
      for(let i=0; i<probs.length; i++) {
        a += probs[i];
        if(r < a) {
          const b = i.toString(2).padStart(this.n, "0");
          out[b] = (out[b] || 0) + 1;
          break;
        }
      }
    }
    return out;
  }

  getStateVector() {
    return this.state.map((c,i) => {
      const prob = abs2(c);
      const phaseVal = phase(c);
      return {
        state: i.toString(2).padStart(this.n, "0"),
        amplitude: c,
        probability: prob,
        phase: phaseVal
      };
    });
  }
}

function exportCircuit() {
  const data = {
    nQubits: nQubits,
    columns: columns,
    gridData: gridData,
    version: "2.0"
  };
  const blob = new Blob([JSON.stringify(data, null, 2)], {type: "application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "quantum_circuit.json";
  a.click();
  URL.revokeObjectURL(url);
}

function importCircuit() {
  const input = document.createElement("input");
  input.type = "file";
  input.accept = ".json";
  input.onchange = e => {
    const file = e.target.files[0];
    const reader = new FileReader();
    reader.onload = e => {
      try {
        const data = JSON.parse(e.target.result);
        nQubits = data.nQubits;
        columns = data.columns;
        gridData = data.gridData;
        document.getElementById("qubitsInput").value = nQubits;
        renderGrid();
        createBlochSpheres();
        runCircuit();
      } catch(err) {
        alert("Error loading circuit file");
      }
    };
    reader.readAsText(file);
  };
  input.click();
}

document.addEventListener('DOMContentLoaded', () => {
  document.getElementById("autoRun").checked = true;
  autoRunEnabled = true;
  initGrid();
});

document.addEventListener("dragover", e => e.preventDefault());
document.addEventListener("drop", e => e.preventDefault());
</script>
</body>
</html>